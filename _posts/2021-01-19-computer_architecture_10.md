---
title: "컴퓨터 구조 요약 - 입출력 구조"
last_modified_at: 2021-01-20
excerpt: ""
categories:
  - computer_architecture
---

## 1. 산술 연산
덧셈, 뺄셈, 곱셈, 나눗셈에 대한 하드웨어 구성과 알고리즘, 흐름도가 있다.

## 2. 입출력 인터페이스
입출력 인터페이스는 메모리나 CPU 레지스터와 같은 내부 저장 장치와 외부 입출력 장치간의 이진 정보를 전송하기 위한 방법을 제공하는 특별한 하드웨어이다. 
아래와 같이 내부 장치와 입출력 장치(주변 장치)간의 차이가 있으므로, 인터페이스는 정보 전송을 감시하고 동기화한다. 입출력 장치 또한 자신의 제어기를 가질 수도 있다. 
1. 주변 장치는 전기 기계적이거나 전자기적인 잔치로, 동작 방식이 전기적 장치인 CPU와 메모리와 다르다. 따라서 신호값의 변환이 필요할 수 있다.
2. 주변 장치의 데이터 전송 속도는 CPU 보다 느리다. 따라서 동기화 절차가 필요하다.
3. 주변 장치의 데이터 코드와 형식이 CPU나 메모리의 형식과 다르다.
4. 주변 장치들의 동작 방식이 서로 다르다.

---

입출력 버스는 주변 장치의 인터페이스에 공통적으로 연결된 버스이다. 
장치와 통신하기 위해 CPU가 버스에 장치 주소를 지정하면, 주소에 해당하는 장치와 입출력 버스 사이의 통로가 활성화된다. 
이후 프로세서가 I/O 커맨드를 선택된 인터페이스에게 보내면 인터페이스는 해당 명령어를 실행한다.
네 종류의 커맨드가 있다.
1. 제어 커맨드 - 주변 장치를 활성화시키며 무엇을 해야 할지를 전달한다.
2. 테스트 커맨드 - 주변 장치내에 있는 상태를 테스트하기 위해 사용한다.
3. 데이터 출력 커맨드 - 입출력 버스내에 있는 데이터 라인으로부터 데이터를 받아들이도록 인터페이스가 작용하게 한다.
4. 데이터 입력 커맨드 - 인터페이스가 주변 장치로부터 데이터를 받아 버퍼 레지스터에 놓도록 한다. 

---

프로세서는 I/O 뿐만 아니라 메모리 장치와도 통신을 수행한다. 
컴퓨터의 버스가 I/O와 메모리와 통신하는 세 가지 방법은 다음과 같다. 
1. 메모리와 I/O, 각각 분리된 버스 사용
2. 메모리와 I/O, 공통 버스, 각각 분리된 제어 라인 사용
3. 메모리와 I/O, 공통 버스, 공통 제어 라인 사용

1번은 독립적인 I/O프로세서(IOP)를 가진 컴퓨터에서 사용한다. 
2번은 입출력 명령어를 fetch하고 OP코드를 해독할 때, I/O 제어 라인을 인에이블시킨다.
3번은 인터페이스 레지스터 주소를 메모리 시스템의 하나의 부분으로 취급한다. 
인터페이스 레지스터를 지정하는 주소는 메모리 주소 지정에는 사용할 수 없기에, 메모리 주소 용량이 줄어든다. 

## 3. 데이터 전송
컴퓨터 내부의 연산은 공통 클럭 펄스에 의하여 동기화되어 있다. 
클럭 펄스는 장치내의 모든 레지스터에 인가되며, 레지스터 사이의 데이터 전송은 클럭 펄스가 발생하는 동안 동시에 이루어진다. 
하지만 서로 독립적으로 설계된 장치들의 경우, 대부분 자신의 클럭 펄스를 갖게 되어 일치하지 않는다. 
이런 비동기적인 데이터 전송을 위해서는 데이터가 전송될 시각을 알리는 신호가 교환되어야 한다. 

---

# 스트로브 펄스를 활용한 동기 제어
각 전송의 시간을 맞추기 위해 단 하나의 제어 라인을 사용한다. 
송신 장치과 수신 장치 사이에는 데이터를 운반하는 데이터 버스와 유용한 데이터가 버스에 있음을 알리는 스트로브가 존재한다. 
송신 장치 혹은 수신 장치에서 전송 시작을 개시할 수 있다.
1. 송신 장치에서 전송 시작 개시
	- 송신 장치에서 데이터를 데이터 버스에 올리고 스트로브 펄스를 발생시킴
	- 수신 장치가 데이터를 받아들일 만큼 충분한 시간 동안 데이터를 활성화된 상태로 만듦 
	- 수신 장치가 데이터를 받아들였는지의 여부를 알 수 없음
2. 수신 장치에서 전송 시작 개시
	- 수신 장치에서 스트로브 펄스를 발생시킴 
	- 송신 장치가 데이터를 제공함 
	- 송신 장치가 유효한 데이터를 버스에 올렸는지 알 수 없음
스트로브의 falling edge(high->low)는 수신 장치에서 데이터를 내부 레지스터에 전송시키기 위해 사용할 수 있다. 

---

# 핸드셰이킹를 통한 동기 제어
스트로브를 통한 제어의 문제점을 해결하기 위한 방법이다. 
이는 전송을 시작한 장치에 응답하는 제 2의 제어 신호를 추가한다. 
1. 송신 장치에서 전송 시작 개시
	- 송신 장치에서 데이터를 버스에 올리고 data valid 신호를 보냄
	- 수신 장치가 버스에서 데이터를 받은 후 data accepted 신호를 보냄
	- 송신 장치에서 data valid 신호를 무효화
	- 수신 장치에서 data accepted 신호를 무효화
2. 수신 장치에서 전송 시작 개시
	- 수신 장치에서 ready for data 신호를 보냄
	- 송신 장치에서 데이터와 data valid 신호를 보냄
	- 수신 장치에서 ready for data 신호를 무효화
	- 송신 장치에서 data valid 신호를 무효화
핸드셰이킹 방식은 높은 신뢰성을 갖는다. 두 장치가 전부 정상적으로 동작할 때만 데이터 전송이 성공한다. 
한 장치가 잘못되어 데이터 전송이 이루어지지 않으면 타임아웃(timeout)에러가 발생한다. 
전송이 일정 시간안에 이루어 지지 않으면, 프로세서는 인터럽트를 발생시켜 에러 검출 서비스 루틴을 수행한다. 

---

# 비동기 직렬 전송
비동기 직렬 전송에서 문자 코드의 양 끝에 특수한 시작, 정지 비트가 들어간다. 
대표적인 비동기 통신 인터페이스는 이중 버퍼 방식을 사용한다. 이는 이전 문자의 전송이 시작되자마자 새로운 문자가 레지스터에 저장될 수 있다. 
1. 송신부 동작
	- CPU가 상태 레지스터를 읽어 송신부 레지스터가 비어 있는지 확인한다.
	- 비어 있으면 송신부 레지스터에 데이터를 전송시킨다.
	- 송신부 레지스터의 데이터는 시프트 레지스터로 병렬 전송 죈다.
	- 시프트 레지스터의 첫번째 비트는 시작 비트를 나타내는 0이 되고, 적절한 수의 정지 비트가 뒤에 붙는다.
2. 수신부 동작
	- 0의 신호를 가진 시작 비트를 발견하면 데이터를 시프트 레지스터에 저장한다.
	- 패리티 비트와 정지 비트를 체크하고 이를 없앤다.
	- 시프트 레지스터에서 수신부 레지스터로 데이터를 병렬 전송하고, 수신부 레지스터가 가득 찼다고 상태 레지스터를 변경한다.
	- CPU가 상태 레지스터를 읽어 수신부 레지스터로부터 데이터를 읽는다.

인터페이스는 데이터 전송시 일어나는 에러를 조사한다. 
1. 패리티 에러 - 받은 데이터의 1의 개수가 옳은 패리티가 아님
2. 프레밍 에러 - 정지 비트의 개수가 맞지 않음
3. 오버런 에러 - CPU가 수신부 레지스터를 읽기 전에, 다음 문자가 시프트 레지스터에서 전송 됨

제일 처음 들어온 항목이 제일 처음에 나가게 정보를 저장하는 FIFO버퍼도 비동기 직렬 전송에 사용 될 수 있다. 
이는 데이터 입력과 출력을 다른 속도로 할 수도 있다. 

---

# 전송 모드
컴퓨터와 I/O장치 사이의 데이터 전송은 여러 가지 모드로 나뉘어진다. 
CPU를 중간 경로로 간주하는 것(1, 2번)과 데이터를 직접 메모리로 전송하는 것(3번)들이 있다. 
많은 컴퓨터는 인터페이스의 논리 회로와 DMA전송을 위한 요소를 결합하며, 이를 데이터 채널이라 부른다. 
데이터 채널은 인터럽트와 DMA를 통하여 주변 장치를 조정하는 입출력 프로세서이다. 
1. 프로그램된 I/O
2. 인터럽트에 의한 I/O
3. 직접 메모리 접근(DMA)

---

# 프로그램된 I/O
프로그램으로 제어되는 동작은 컴퓨터 메모리내에 쓰여진 입출력 명령어에 의해서 이루어진다. 
프로그램 제어하의 데이터 전송은 프로세서가 주변 장치를 끊임없이 감시해야 한다. 
그리고 데이터의 전송은 입출력 버스를 통하여 프로세서와 주변 장치 사이에서 이루어진다. 
I/O장치는 핸드셰이킹 방식으로 인터페이스로 데이터를 전송한다. 
다음에 인터페이스는 상태 레지스터의 플래그 비트를 세트한다. 
그 후 프로그램을 통해 데이터를 CPU레지스터로 읽어오고 메모리로 전송한다. 
CPU는 끊임없이 상태 레지스터를 읽는 프로그램 때문에 다른 작업을 위한 시간을 낭비하게 된다. 

---

# 인터럽트에 의한 I/O
프로그램된 I/O에서 프로세서가 시간을 낭비하므로, 인터럽트 기능을 사용하여 이를 방지한다. 
프로세서는 다른 프로그램을 수행하고 있고 인터페이스가 주변 장치를 감시한다. 
주변 장치가 준비되었다고 결정하면, 프로세서에게 인터럽트를 보낸다. 
프로세서는 진행 중인 작업을 잠시 중지하고 데이터 전송 서비스 루틴으로 분기한다. 

---

# 직접 메모리 접근(DMA)
CPU를 거치지 않고, 주변 장치가 직접 메모리 버스를 관리한다면 전송 속도가 증가할 것이다. 
하지만 직접 메모리 접근 전송이 수행되는 동안 CPU는 메모리 버스를 제어하지 못하고 쉬게 된다. 
CPU와 DMA는 버스 요구(bus request), 버스 승인(bus grant) 제어 라인을 통해 연결되어있다. 
DMA가 버스 요구 신호를 보내고 CPU가 버스 승인을 보내면, DMA가 버스를 장악하여 프로세서의 개입없이 메모리 전송을 수행한다. 
DMA를 이용하여 데이터를 전송하는 데에는 몇가지 방법이 있다. 
DMA대량 전송은 메모리 버스를 제어하고 있는 동안, 여러 개의 메모리 워드로 구성된 블럭을 지속적으로 전송한다. 
사이클 스틸링은 한번에 한 데이터 워드를 전송하고 CPU에게 버스의 제어를 돌려준다. 따라서 CPU는 단지 한번의 메모리 사이클을 DMA에게 뺏기게 된다. 
DMA제어기는 세 개의 레지스터를 가지고 있고, CPU에 의하여 초기화 된 다음, 전체 블럭이 모두 전송될 때까지 메모리와 주변 장치 사이에서 데이터를 전송한다. 
CPU는 데이터 버스를 통하여 DMA에게 사용할 메모리 블럭의 시작 주소, 블럭의 워드 수, 읽기 혹은 쓰기같은 전송 모드, 시작 제어를 보내어 DMA를 초기화 한다. 
  
---

# 주변 장치 소프트웨어적 제어
컴퓨터 시스템에 주변 장치를 인터페이스하기 위한 하드웨어에 더해 소프트웨어 제어가 필요하다. 
주변 장치의 제어, 데이터 전송, 장치 상태 조사, 장치 활성화, 데이터 채널 개시 등 프로그램이 필요하다. 
특히 입출력 장치의 소프트웨어 제어는 매우 복잡하기에, 표준적인 입출력 루틴은 컴퓨터 시스템의 부분으로서 제작회사에 의해 준비된다. 
OS내에 다양한 I/O프로그램들이 포함될 수도 있다.  

## 4. 인터럽트
CPU가 장치의 상태를 알기 위하여 계속 플래그를 조사하는 것은 시간 낭비이다. 
따라서 플래그가 인에이블되었을 때마다 디바이스 인터페이스가 CPU에 인터럽트를 요구한다. 
CPU는 서비스 루틴으로 분기하여 인터럽트 신호에 응답한다. 
분기 주소를 선택하는 방법에는 벡터, 비벡터 인터럽트가 있다. 
비벡터 인터럽트 방식에서 분기 주소는 메모리의 고정 위치에 있다. 
반면 벡터 인터럽트 방식은 인터럽트를 내는 소스가 인터럽트 벡터라 불리는 분기에 대한 정보를 제공한다. 
인터럽트 시스템은 어떤 장치가 인터럽트를 발생하였는지 알아야 하며, 
동시에 여러 개의 인터럽트가 발생하였을 경우에 어떤 장치를 먼저 서비스할지 결정해야 한다. 
이를 위해 각 장치에 우선순위를 부여한다. 
소프트웨어로 인터럽트를 발생시키고, 높은 우선순위를 가진 장치를 찾으려면 모든 장치를 조사해야한다. 
조사하는 시간을 줄이기 위해 하드웨어적인 방법을 사용할 수 있다.

---

# 데이지 체인 우선순위 인터럽트
데이지 체인 방법은 인터럽트를 발생하는 모든 장치들을 직렬로 연결함으로써 이루어진다. 
우선순위가 높은 장치를 선두로 우선순위에 따라 연결한다. 
장치들 중 하나라도 인터럽트를 요구하면, 공유된 인터럽트 요구라인을 통해 인터럽트가 CPU에게 전달된다. 
그러면 CPU는 인터럽트 승낙 라인을 활성화시켜 신호를 보낸다. 
우선순위가 높은 장치가 먼저 신호를 받고, 해당 장치가 인터럽트를 요구했다면 VAD(vector address)를 CPU에게 보낸다. 
아니라면 신호를 다음 장치에게 넘긴다. 

---

# 병렬 우선순위 인터럽트
병렬 우선순위 인터럽트 방법은 각 장치의 인터럽트 요청에 따라 각 비트가 개별적으로 세트될 수 있는 인터럽트 레지스터를 사용한다. 
우선순위는 이 레지스터의 비트의 위치에 의해 결정된다. 
또한 각 인터럽트 요청의 상태를 조절할 수 있는 마스크 레지스터를 갖고 있다. 
인터럽트 레지스터 비트와 마스크 레지스터의 AND연산 결과가 우선순위 인코더로 들어간다. 
우선순위 인코더는 두개 이상의 입력이 동시에 들어왔을 때, 높은 우선순위의 입력에 해당하는 출력만을 만든다. 
예를 들어, 1순위 입력이 들어왔다면 나머지 입력(2, 3순위 ...)에 상관없이 출력(VAD)이 나온다. 
플립플롭 IEN도 활용되는데, 프로그램내에서 IEN의 값을 0으로 하여 인터럽트 기능을 사용하지 않게 할수도 있다. 
인터럽트 사이클에서는 VAD가 PC로 전송되면 IEN 값이 0으로 되어 더이상의 인터럽트를 금지한다. 
그리고 인터럽트 사이클 마지막에 클리어된다.  

---

우선순위 인터럽트 시스템은 인터럽트의 요청을 서비스하거나 인터럽터 하드웨어 레지스터를 관리하기 위해 소프트웨어 루틴을 필요로 한다. 
각 장치의 지정된 벡터 주소에는, 메모리에 저장된 I/O 서비스 프로그램으로 분기하는 점프(jump) 명령어가 있다. 
스택에 돌아와야할 현재 주소를 저장하고 분기하며, 더 높은 우선순위의 인터럽트가 요청되면 이를 반복한다. 

각 인터럽트 서비스 루틴은 하드웨어 인터럽트 시스템내의 레지스터를 조정하기 위해 초기 동작과 최종 동작을 가져야 한다. 
초기 동작은 다음과 같다. 
1. 보다 낮은 단계의 마스크 레지스터르 비트를 0으로 하여 낮은 단계의 인터럽트를 막는다.
2. 더 높은 단계의 인터럽트가 올 수 있도록 인터럽트 상태 비트 IST를 클리어 한다. 
3. 프로세서의 레지스터 내용을 보관한다.
4. 더 높은 단계의 인터럽트를 위해 인터럽트 인에이블 비트 IEN을 1로 세트한다. 
5. 서비스 루틴을 진행한다.

최종 동작은 다음과 같다.
1. 인터럽트 인에이블 비트 IEN을 0으로 클리어한다. 
2. 프로세서 레지스터의 내용을 복원한다. 
3. 서비스된 자원에 속하는 인터럽트 레지스터의 비트를 0으로 클리어한다. 
4. 낮은 단계의 인터럽트를 위해 마스크 레지스터의 보다 낮은 우선순위의 비트를 1로 세트한다.
5. 돌아가야할 주소를 PC에 복원하고 다음 인터럽트를 위해 IEN을 1로 세트한다.

---

## 5. 입출력 프로세서
각 인터페이스가 CPU와 통신하게 하는 대신 컴퓨터에 하나 이상의 프로세서를 두어 입출력 장치와의 직접적인 통신을 전담하게 할 수 있다. 
Input-output processor(IOP)는 입출력 장치와 직접 통신하며 데이터 채널이라고도 불린다. 
CPU에 의해 동작이 모두 지정되는 DMA제어기와 달리 IOP는 고유의 명령어를 실행시킬 수 있다. 
주변 데이터 형식은 메모리와 CPU의 데이터 형식과 다르기 때문에 IOP는 이를 재구성한다. 
IOP는 입출력 장치로부터 받은 8비트 문자를 모아 32비트의 한 워드로 구성한다. 
하나의 메모리 워드로 구성이 되면 CPU로부터 한 메모리 사이클을 훔쳐 메모리로 전송한다. 

# CPU-IOP 통신
CPU와 IOP 사이의 통신은 컴퓨터에 따라 다르지만, 대부분의 경우 메모리 장치가 메세지의 집중지로서 작동한다. 
간소화된 통신의 예는 다음과 같다. 
1. CPU가 IOP, IOP장치의 상태를 검사하기 위해 명령어를 보냄
2. IOP는 정해진 메모리 주소에 상태 워드를 기록함으로써 응답함
3. CPU는 다른 프로그램을 실행시키고, IOP는 DMA을 활용하여 I/O 전송을 수행함
4. I/O 전송이 완료되면 CPU에게 인터럽트 신호를 보내고 1, 2번 절차를 수행함

---

## 6. 직렬 통신
데이터 통신 프로세서는 다른 원격 단말 장치로부터 데이터를 받거나 보내는 입출력 프로세스이다. 
이는 데이터 통신망과 직접 통신할 수 있도록 설계된 특수 입출력 프로세서이다. 

전송 에러는 검출하는 방식에는 longitudinal redundancy check(LRC), cyclic redundancy check(CRC)를 추가적으로 전송하는 방법이 있다. 
수신부에서 받은 문자를 가지고 다시 LRC, CRC를 계산했을 때, 전송된 값과 다르면 전송부에게 다시 전송하도록 요청한다. 
LRC는 모든 전송된 문자의 exclusive-OR의 결과이다. 
CRC는 현재 상태에 선형 연산을 취해 다음 상태를 얻는 선형 피드백 시프트 레지스터를 통해 얻어지는 결과이다. 
선형 연산은 주로 exclusive-OR를 사용하며, 새로운 값이 레지스터의 왼쪽 값에 시프트되어 추가된다. 
CRC는 회선의 접촉 불량 등의 원인으로 짧은 시간에 데이터에 집단적으로 오류가 발생하는 버스트 에러(burst error)를 검출하는데 유효하다. 

두 지점 사이에 데이터를 전송하는 방법은 세가지가 있다. 
1. simplex - 한 방향으로만 정보를 전송한다.
2. half-duplex - 두 방향으로 전송할 수 있으나, 동시에 전송할 수 없다.
3. full-duplex - 두 쌍의 라인을 통해 동시에 두 방향으로 데이터를 주고받는다. 

---

# 프로토콜
두개 이상의 국(station) 사이에 정보를 전송하기 위해 쓰이는 통신선, 모뎀 및 다른 장비를 데이터 링크라 부른다. 
데이터 링크의 순서적인 정보 전달은 따라야 하는 법칙, 프로토콜에 의하여 달성된다. 
프로토콜은 문자지향 프로토콜과 비트지향 프로토콜로 나눌 수 있다. 

---

# 문자지향 프로토콜
정보 전송을 제어하는 통신 제어 문자를 사용한다. 
전송하려는 메세지에 통신 제어 문자를 추가하여 동기화 및 에러를 탐지한다. 
헤더 필드에는 주소 및 제어 정보가 담겨져 있다. 

문자지향 프로토콜은 프로그램과 데이터를 보낼 경우 비효율적이다. 
통신 제어 문자에 속하지만, 텍스트 데이터인 8비트 형식이 수신부에 의해, 통신 제어 문자로 잘못 해석될 우려가 있기 때문이다. 
이런 비트가 텍스트 데이터에 나올 때마다 DEL(data link escape) 제어 문자를 삽입하여 해결 하는 방법이 있지만, 비효율적이고 구현이 힘들다. 

---

# 비트지향 프로토콜
비트지향 프로토콜은 문자를 쓰지 않으며, 제어 문자 처럼 어떤 특별한 코드와도 무관하다. 
플래그 비트를 사용하여 시작과 종료를 나타낸다. 그리고 중간에 플래그 비트가 생기지 않도록 "zero삽입"을 수행한다. 
플래그 비트가 01111110 일 때, 데이터에 1이 다섯 개 연속으로 있다면 0을 삽입한다. 
그래서 비트 형식 0111111 은 01111101으로 전송되고 수신부에서 다시 0111111로 저장된다. 