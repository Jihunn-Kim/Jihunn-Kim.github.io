---
title: "운영체제 요약 - 12. 대용량 저장장치 구조
last_modified_at: 2021-02-13
show_date: true
classes: wide
excerpt: ""
categories:
  - operating_system
---

## 1. 대용량 저장장치의 개관

### 1.1. 자기 디스크(Magnetic Disks)
각 디스크의 플래터(platter)는 원형 평판 모양이다. 
플래터의 양쪽 표면은 자기 물질로 덮여 있다. 
정보를 플래터 상에 자기적으로 기록하여 저장한다. 

읽기/쓰기 헤드는 모든 플래터의 각 표면 바로 위에서 움직인다. 
헤드는 모든 헤드를 한꺼번에 이동시키는 디스크 암(disk arm)에 부착되어 있다. 

플래터의 표면은 원형인 트랙(track)으로 논리적으로 나뉘어져 있고, 이것은 다시 섹터(sector)로 나뉘어져 있다. 
동일한 암 위치에 있는 트랙의 집합은 하나의 실린더(cylinder)를 형성한다. 

디스크가 사용 중일 때, 드라이브 모터는 고속으로 회전한다. 
이는 분당 회전수(RPM) 단위로 표현된다. 

디스크 속도는 두 가지 구성요소로 이루어진다. 
전송률(transfer rate)는 드라이브와 컴퓨터간의 데이터 흐름 비율이다. 
임의 접근 시간(random access time)이라고도 하는 위치 잡기 시간(positioning time)은 
원하는 실린더로 디스크 암이 움직이는 탐색 시간(seek time)과 원하는 섹터로 디스크 헤드가 회전하는 데 필요한 시간인 회전 지연(rotational latency)으로 구성된다. 

디스크 드라이브는 입출력 버스라고 하는 회선들의 집합에 의해 컴퓨터에 장착된다. 
ATA(Advanced Technology Attachment), SATA(Serial ATA), USB(Universal Serial Bus) 등 여러 종류의 버스가 이용 가능하다. 

버스 상에서 데이터 전송은 제어기(controller)라고 하는 특별한 전자 처리기에 의해 수행된다. 
호스트 제어기는 버스의 컴퓨터 쪽 끝에 있다. 
디스크 제어기는 각각의 디스크 드라이브에 내장되어 있다. 

디스크 입출력 연산을 수행하기 위해, 컴퓨터는 호스트 제어기에 명령을 넣는다. 
이어 호스트 제어기는 메세지를 통해 명령을 디스크 제어기로 보내고, 이는 명령을 수행하기 위해 디스크 드라이브 하드웨어를 작동시킨다. 
보통 디스크 제어기는 내장 캐시를 가지고 있다. 
디스크 드라이브에서의 데이터 전송은 캐시와 디스크 표면 사이에서 일어나고, 데이터는 빠른 전자 속도로 캐시와 호스트 제어기 사이에서 전송된다. 

### 1.2. 반도체 디스크(Solid-State Disk)
SSD는 하드 디스크와 같은 특성을 갖고 있지만, 기계적 이동 부품이 없기 때문에 더 신뢰할 수 있으며, 탐색이나 지연 시간이 없기 때문에 속도가 더 빠르다. 
전력 소모도 적으나, 비싸고 수명이 상대적으로 짧다. 

SSD는 디스크 헤드가 없기 때문에, 일반적으로 디스크 스케줄링 알고리즘이 잘 적용되지 않는다(FCFS나 변형을 사용).  
그러나 처리량과 포맷팅은 일반적 디스크 특성과 부합된다. 

### 1.3. 자기 테이프(Magnetic Tapes)
디스크보다 무작위 접근이 매우 느려, 주로 예비용이나 자주 사용하지 않는 정보의 저장에 사용된다. 

## 2. 디스크 구조
자기 디스크들은 크기가 일정한 논리 블록(logical block)들의 일차원 배열처럼 취급된다. 
정보 전송은 항상 이 블록 단위로만 이루어지며, 각 논리 블록에는 주소가 붙여진다. 

논리 블록들을 가장 바깥쪽 실린더의 첫 번째 트랙의 첫 번째 섹터부터 매핑해가면, 
논리 블록 번호를 실린더 번호, 트랙 번호, 섹터 번호로 변환할 수 있다. 

하지만 이 변환에는 어려움이 있다. 
대부분의 디스크에는 결함이 생긴 섹터가 있으나, 매핑이 이를 다른 섹터로 진행하여 결함을 숨긴다. 
또한 일부 디스크는 트랙당 섹터의 수가 일정하지 않다. 
트랙이 디스크의 중심으로부터 멀어질 수록 트랙은 길이가 더 길어져 더 많은 섹터를 가질 수 있다. 

고정 선형 속도(CLV, Constant Linear Velocity)를 사용하는 장치(CD-ROM, DVD-ROM)에서는 트랙당 비트의 밀도가 일정하다. 
여기에서 헤드는 바깥쪽에서 안쪽 트랙으로 이동하면서, 헤드 아래를 통과 하는 데이터의 비율을 맞추기 위해 회전 속도를 높인다. 

하드 디스크는 고정 각 속도(CAV, Constant Angular Velocity)를 사용한다. 
이는 디스크의 회전 속도를 일정하게 유지하고, 안쪽 트랙에서 바깥쪽 트랙으로 갈수록 비트의 밀도를 줄인다. 

## 3. 디스크 부착(Dist Attachment)

### 3.1. 호스트 부착 저장장치(Host-Attached Storage)
호스트에 부착된 저장장치는 로컬 입출력 포트를 이용하여 접근된다. 
데스크톱 컴퓨터는 ATA, SATA 등을 사용한다. 
고성능 워크스테잉션과 서버는 일반적으로 광섬유 채널(FC)과 같은 더 정교한 입출력 구조를 사용한다. 

### 3.2. 네트워크에 부착된 저장장치(Network-Attached Storage)
네트워크에 부착된 저장장치(NAS)는 데이터 네트워크를 통해 원격으로 접속되는 저장장치이다. 
클라이언트는 유닉스의 NFS 또는 윈도우의 CIFS 같은 원격 프로시저 콜(RPC)을 통해 네트워크에 부착된 저장장치를 접근한다. 
원격 프로시저 콜은 IP 네트워크 상의 TCP 또는 UDP를 통해 전달되는데, 이 네트워크는 보통 클라이언트에게 모든 데이터를 전송하는 같은 LAN(Llocal-Area Network)이다. 
따라서 NAS를 하나의 저장장치 접근 프로토콜이라고 생각하기 쉽다. 
NAS는 보통 RPC 인터페이스를 구현한 소프트웨어를 가진 RAID(12.7절)로 구현된다. 

iSCSI는 네트워크로 연결된 저장장치 프로토콜이다. 이것은 SCSI프로토콜을 전송하기 위해 IP 네트워크를 사용한다. 
따라서 SCSI 케이블들이 아닌 네트워크가 호스트들과 호스트들의 저장장치를 연결한다. 

### 3.3. SAN(Storage-Area Network)
네트워크에 부착된 저장 시스템의 단점 중 하나는 저장장치의 입출력 연산 시 데이터 네트워크의 대역폭을 소비하는 점이고, 
이로 인해 네트워크 통신의 지연을 증가시키는 것이다. 

SAN은 서버들과 저장장치 유닛들을 연결하는 사유 네트워크(네트워크 프로토콜을 사용하지 않고 저장장치 프로토콜을 사용)이다. 
여러 호스트와 저장장치가 같은 SAN에 부착될 수 있고, 저장장치는 동적으로 호스트에 할당될 수 있다. 

SAN 내부 연결에는 iSCSI, FC가 사용될 수 있다. 
다른 연결 구조는 InfiniBand 가 있고, 이는 서버들과 저장장치들을 연결하는 고속의 내부연결망을 지원하는 하드웨어와 소프트웨어를 제공한다. 

## 4. 디스크 스케줄링(Disk Scheduling)
디스크 스케줄링은 접근시간(탐색시간, 회전 지연)과 단위 시간당 전송되는 바이트 수를 나타내는 디스크 대역폭을 향상시킬 수 있다. 

### 4.1. 선입 선처리 스케줄링(FCFS, First-Come-First-Served Scheduling)
디스크 큐에 먼저 들어온 입출력 요청을 먼저 처리한다. 

### 4.2. 최소 탐색 시간 우선 스케줄링(SSTF, Shortest-Seek-Time-First Scheduling)
SSTF는 현재 헤드 위치에서 탐색 시간이 가장 적은, 즉 가장 가까운 요청을 먼저 처리한다. 

### 4.3. SCAN 스케줄링
SCAN에서는 디스크 암이 디스크의 한 끝에서 시작하여 다른 끝으로 이동하며, 가는 길에 있는 요청을 모두 처리한다. 
다른 한쪽 끝에 도달하면(또는 그쪽 방향에 더이상 대기하고 있는 요청이 없으면), 역방향으로 이동한다. 
따라서 헤드는 디스크 양쪽을 계속해서 가로지르며 왕복한다. 

### 4.4. C-SCAN 스케줄링
C-SCAN(Circular-SCAN)은 SCAN의 변형이다. 
한쪽 방향으로 헤드를 이동해 가면서 요청을 처리하지만, 한쪽 끝에 다다르면 디스크의 시작 지점으로 이동한다. 
시작 지점으로 돌아가는 동안 어떤 요청도 처리하지 않는다. 
C-SCAN은 실린더들을 마지막 실린더가 처음 실린더와 맞닿은 원형 리스트로 간주한다. 

### LOOK 스케줄링
헤드를 디스크의 끝에서 끝으로 이동하는 것이 아니라, 그 방향에서 기다리는 요청이 없으면 헤드의 이동 방향을 즉시 반대로 바꾼다. 
이는 한 방향으로 계속 움직이기 전에 미리 요구가 있는지 확인한다. 

### 4.6. 디스크 스케줄링 알고리즘의 선택
어느 스케줄링 알고리즘을 사용하든, 그 성능은 요청의 형태와 횟수에 좌우된다. 
디스크 서비스는 파일을 디스크 공간에 어떻게 배열했느냐 와도 상관 관계가 많다. 
디렉터리와 색인 블록의 위치 또한 중요하다. 

스케줄링 알고리즘을 디스크 드라이브에 내장된 제어기 하드웨어 내에 구현할 수도 있다. 
운영체제가 제어기에게 요청을 보내면, 제어기는 이를 스케줄하여 탐색 시간과 회전 지연을 최적화 한다. 

성능만을 디스크 입출력에서 고려해야 할 유일한 사항이라면 디스크 스케줄링을 모두 디스크 하드웨어가 할 수도 있다. 
하지만 성능 이외에도 작업들의 우선순위라든가, 디렉터리가 파일보다 먼저 디스크에 쓰여지는 신뢰성 등 고려할 것이 많다. 

## 5. 디스크 관리

### 5.1. 디스크 포맷팅(Disk Formatting)
디스크는 자료를 저장하기 전에 섹터들로 나누어져야 하며, 이 과정을 저수준 포맷팅(low-level formatting) 또는 물리적 포맷팅이라고 부른다. 
저수준 포맷팅은 섹터를 구분하기 위해 디스크를 적절한 자료구조로 채우는 것이며, 섹터의 자료구조는 보통 헤더(header), 자료 구역(보통 512B data area), 트레일러(trailer)로 구성된다. 

헤더와 트레일러는 섹터 번호와 오류 수정 코드(ECC, Error-Correcting Code)와 같은 정보를 가지고 있다. 
ECC는 한두 개의 비트만 잘못되었을 때는 이를 교정할 수 있는 정보를 가지고 있다. 
디스크 제어기가 섹터에 데이터를 쓸 때, 데이터 값으로부터 ECC를 구해서 같이 기록한다. 
나중에 이 섹터가 읽혀질 때, 그 데이터로부터 ECC가 다시 계산되고 이것이 저장되었던 ECC값과 비교된다. 
비교된 값들이 서로 다르면, 섹터에 문제가 생긴 것이다. 

디스크에 파일을 저장하기 전에, 운영체제는 디스크에 운영체제의 자료구조를 기록한다. 
먼저, 디스크를 여러 실린더로 이루어지는 파티션(partition)으로 나눈다. 
운영체제는 각 파티션을 각각 별도의 디스크처럼 취급한다. 
그 후 논리적 포맷(logical formatting), 즉 파일 시스템을 만든다. 
운영체제는 FAT, inode, 가용 공간 정보, 초기의 빈 디렉토리 구조 등을 포함한 파일 시스템 자료구조를 디스크에 저장한다. 

효율성을 위해 대부분의 파일 시스템들은 블록들을 클러스터(cluster)라고 하는 묶음으로 그룹화한다. 
디스크 입출력은 블록 단위로 수행되나, 파일 시스템의 입출력은 클러스터 단위로 수행된다. 
입출력이 순차 접근은 많은 반면, 임의 접근은 적기 때문이다. 

어떤 운영체제는 디스크 파티션을 운영체제의 파일 시스템없이 논리 블록들의 배열처럼 사용할 수 있도록 해주기도 한다. 
이와 같은 논리 블록들의 배열을 raw disk라 하고, 이 배열에 대한 입출력을 raw 입출력이라 한다. 
데이터베이스 시스템과 같은 특정 응용 프로그램은 자료가 저장되어 있는 위치를 자신이 제어하기에 raw 입출력을 더 선호한다. 

### 5.2. 부트 블록(Boot Block)
대부분의 시스템에서 ROM에는 부트스트랩 프로그램을 디스크로부터 적재하는 일만 하는 부트스트랩 로더(bootstrap loader) 프로그램을 저장한다. 
따라서 부트스트랩 프로그램은 쉽게 변경이 가능하다(새로운 버전을 디스크에 저장). 
부트스트랩 프로그램은 디스크의 고정된 위치인 부트 블록에 저장된다. 
부트 파티션을 가지고 있는 디스크는 부트 디스크 또는 시스템 디스크라 불린다. 

부트스트랩 로더는 디스크 제어기에게 부트스트랩 프로그램을 메모리에 올리도록 지시하고, 그 프로그램을 실행한다. 
부트스트랩 프로그램은 디스크 내에 저장되어있는 운영체제 커널을 찾고 그것을 시작한다. 

Winodws의 예는 다음과 같다. 
Windows에서는 부트 파티션이라는 한 파티션에 운영체제와 디바이스 드라이버들을 저장한다. 
Windows의 부트 코드는 하드디스크에 첫 번째 섹터에 저장된다(master boot record, MBR). 
MBR에는 부트 코드뿐만 아니라 하드디스크에 대한 파티션 테이블과 어느 파티션에서 부트가 되어야 하는가에 대한 표시도 있다. 

ROM의 코드는 시스템이 MBR에 있는 부트 코드를 읽도록 한다. 
시스템이 부트 파티션을 찾으면, 해당 파티션의 첫 번째 섹터(부트 섹터)를 읽는다. 
그리고 여러 서브시스템과 시스템 서비스들을 적재하는 등의 부트 프로세스의 남은 일을 재개한다. 
