---
title: "운영체제 요약 - 5. CPU 스케줄링"
last_modified_at: 2021-01-28
excerpt: ""
categories:
  - operating_system
---

## 1. 기본 개념
다중 프로그래밍에서는 CPU 이용률을 최대화하기 위해 다수의 프로세스들을 메모리 내에 유지한다. 
어떤 프로세스가 입출력 등으로 인해 대기해야 할 경우, 운영체제는 CPU를 다른 프로세스에 할당한다. 

### 1.1. CPU-입출력 버스트 사이클(CPU-I/O Burst Cycle)
프로세스 실행은 CPU 실행과 입출력 대기의 사이클로 구성된다. 
프로세스는 이 두 상태 사이를 왔다 갔다 한다. 
일반적으로 입출력 대기시간으로 인해 CPU 사용 시간이 적은 프로세스들이 많으며, 이러한 분포는 CPU 스케줄링 알고리즘에서 중요하다. 

### 1.2. CPU 스케줄러(CPU Scheduler)
CPU가 유휴 상태가 될 때마다, 운영체제는 준비 완료 큐(ready queue)에 있는 프로세스들 중에서 하나를 선택해 실행한다. 
단기 스케줄러(또는 CPU 스케줄러)가 메모리 내의 프로세스를 선택하여 CPU에게 할당한다. 

### 1.3. 선점 스케줄링(Preemptive Scheduling)
CPU 스케줄링 결정은 프로세스가 네 가지 상황일 때 발생한다. 
1. 실행 상태에서 대기 상태로 전환(입출력, 자식 프로세스 기다림)
2. 실행 상태에서 준비 완료 상태로 전환(인터럽트 등)
3. 대기 상태에서 준비 완료 상태로 전환(입출력 종료 등)
4. 종료할 때

1, 4에서만 스케줄링이 발생하는 경우, 비선점(non-preemptive)라고 한다. 
이는 프로세스가 1, 4 상황이 아니라면 자원을 반환하지 않는다. 
다른 프로세스가 자원에 접근하지 못하므로 실시간 컴퓨팅을 지원하기에는 좋지 않다. 

1~4 전부 가능할 경우 선점(preemptive)라고 한다. 
예를 들어, 정해진 시간이 지나면 다른 프로세스에게 자원이 넘어갈 수 있다. 
다수의 프로세서가 접근하는 공유 데이터의 일관성이 깨질 수 있다. 

### 1.4. 디스패처(Dispatcher)
디스패처는 단기 스케줄러가 선택한 프로세스에게 주는 모듈이다. 
이는 다음과 같은 작업을 포함하며, 하나의 프로세스를 정지하고 다른 프로세스를 시작하는데 소요되는 시간을 디스패치 지연(dispatch latency)이라고 한다.  
* 문맥 교환
* 사용자 모드 전환
* 프로그램 재시작을 위해 프로그램의 적절한 위치로 이동(jump)


## 2. 스케줄링 기준(Scheduling Criteria)
CPU 스케줄링 알고리즘을 비교하기 위한 기준은 아래 외 여러가지가 사용된다. 
* CPU 이용률(utilization)
* 처리량(throughput)
	- 단위 시간당 완료된 프로세스의 개수이다.
* 총처리 시간(turnaroung time)
	- 프로세스의 제출 시간과 완료 시간의 간격이다.
	- 메모리에 들어가기 전 대기 시간, 준비 완료 큐에서 대기한 시간, CPU에서 실행한 시간, 입출력 시간을 합한 시간이다. 
* 대기 시간(waiting time)
	- 실행, 입출력 시간을 제외한 준비 완료 큐에서 대기한 시간이다.
* 응답 시간(response time)
	- 하나의 요구를 제출한 후 첫 번째 응답이 나올때까지의 시간이다.

## 3. 스케줄링 알고리즘(Scheduling Algorithms)
CPU 스케줄링은 준비 완료 큐에 있는 어느 프로세스를 CPU에 할당하는 것인지 결정하는 것이다. 

### 3.1. 선입 선처리 스케줄링(First-Come, First-Served Scheduling)
FIFO 큐를 사용하여 CPU를 먼저 요청하는 프로세스에게 CPU를 할당한다. 
이는 비선점형 알고리즘이기에, 모든 다른 프로세스들이 하나의 긴 프로세스를 기다리는 호위 효과(convoy effect)가 나타날 수 있다. 

### 3.2. 최단 작업 우선 스케줄링(Shortest-Job-First Scheduling, SJF)
CPU 버스트(실행) 시간이 작은 프로세스를 먼저 할당한다. 
장기 스케줄러에서는 사용자가 작업을 제출할 때 지정한 처리 시간 제한을 CPU 버스트 시간으로 사용해 SJF 스케줄링을 할 수 있다. 
하지만, 단기 스케줄러에서는 실제 CPU 버스트 시간을 알 수 없다. 
따라서 이전 CPU 버스트 시간을 지수(exponential) 평균내어 다음 CPU 버스트 시간을 예측한다. 

SJF 스케줄링은 선점형이거나 비선점형일 수 있다. 
선점형일 경우에는, 현재 실행되고 있는 프로세스보다 새로운 프로세스의 CPU 버스트 시간이 더 짧을 경우, 새로운 프로세스가 끼어들어 실행된다. 
선점형 SJF 스케줄링을 최소 잔여 시간 우선(shortest remaining time first) 스케줄링이라고도 한다. 

### 3.3. 우선순위 스케줄링(Priority Scheduling)
우선순위 스케줄링은 선점형, 비선점형이 가능하다. 
우선순위가 높은 프로세스를 스케줄링한다. 
우선순위는 내부적 또는 외부적으로 정해질 수 있다. 
시간 제한, 메모리, 열린 파일 수 등의 내부 요인과 프로세스 중요성, 작업 사용자 등의 외부 요인이 있다. 

이 스케줄링의 주요 문제는 무한 봉쇄(indefinite blocking) 또는 기아 상태(starvation)이다. 
높은 우선순위의 프로세스들이 계속 들어와 낮은 우선순위의 프로세스들이 무한히 대기하는 경우이다. 
한 해결 방안은 노화(aging)이며, 이는 시간이 흐름에 따라 대기 중인 프로세스의 우선순위를 증가시키는 것이다. 

### 3.4. 라운드 로빈 스케줄링(Round-Robin Scheduling, RR)
RR 스케줄링은 선점형이다. 
이는 시간 할당량(time quantum) 또는 시간 조각(time slice)이라 하는 작은 단위의 시간을 사용한다. 
10~100밀리초의 작은 시간이 지나면 다음 프로세스에게 CPU자원이 할당된다. 

시간 할당량이 너무 크면 선입 선처리 스케줄링이 된다. 
반대로 너무 작으면 매우 많은 문맥 교환이 이루어져 비효율적이 된다. 

### 3.5. 다단계 큐 스케줄링(Multilevel Queue Scheduling)
프로세스의 특성에 따라 유형을 나누고, 그에 맞게 여러개의 큐를 만든다.  
예를 들어, 시스템 프로세스, 대화형 프로세스, 일괄처리 프로세스 큐 등으로 나눌 수 있다. 
프로세스는 자신의 유형에 맞는 큐에 들어가게 된다. 

각 큐는 위에서 설명한 서로 다른 스케줄링 알고리즘을 가질 수 있다. 
그리고 큐들간의 스케줄링도 사용된다. 
큐들에 우선순위를 정하거나, 할당 시간을 정할 수 있다.

### 3.6. 다단계 피드백 큐 스케줄링(Multilevel Feedback Queue Scheduling)
다단계 큐 스케줄링에서 프로세스는 하나의 큐에 배정받은 후에 다른 큐로 이동할 수 없다. 
대조적으로, 다단계 피드백 큐 스케줄링에서는 프로세스가 다른 큐로 이동할 수 있다. 

좋은 스케줄러로 동작되기 위해서는 다음과 같은 매개변수 값들이 정해져야 한다.
* 큐의 개수
* 각 큐의 스케줄링 알고리즘
* 프로세스를 높은 우선순위 큐로 올려주는 시기 결정
* 프로세스를 낮은 우선순위 큐로 강등시키는 시기 결정
* 프로세스가 들어갈 큐를 결정

## 4. 스레드 스케줄링(Thread Scheduling)


 