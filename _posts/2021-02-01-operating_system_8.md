---
title: "운영체제 요약 - 8. 메모리 관리 전략
last_modified_at: 2021-02-01
show_date: true
classes: wide
excerpt: ""
categories:
  - operating_system
---

## 1. 배경(Background)
메모리는 각각 주소가 할당된 일련의 바이트들로 구성된다. 
CPU는 PC 레지스터가 가르키는 메모리 주소로부터 다음에 수행할 명령어를 가져온다. 
다음에 명령어를 해독하고 메모리에서 피연산자를 가져와 명령어를 실행한다. 

### 1.1. 기본 하드웨어
CPU가 직접 접근할 수 있는 유일한 범용 저장장치는 주 메모리와 프로세서 자체에 내장되어 있는 레지스터들이다. 
따라서 모든 명령어와 데이터들은 주 메모리와 레지스터에 있어야 한다. 

CPU에 내장되어 있는 레지스터들은 CPU 클록(clock) 1사이클(cycle)내에 접근이 가능하다. 
그러나 메모리 버스를 통해 전송되는 주 메모리의 경우는 많은 CPU 클록 틱(clock tick) 사이클이 소요된다. 
이렇게 지연되는 현상을 해결하기 위해, CPU와 주 메모리 사이에 빠른 속도의 캐시 메모리를 추가한다. 

물리 메모리 접근 속도 차이를 고려하는 것에 추가로 올바른 동작을 보장해야 한다. 
사용자 프로그램이 다른 사용자의 프로그램이나 운영체제의 접근하는 것을 막아야 한다. 
운영체제가 메모리에 CPU와 메모리 간의 접근에 개입하면 성능이 떨어지기 때문에 하드웨어를 통해 해결한다. 

프로세스마다 base, limit 레지스터에 메모리 주소의 기준과 상한를 둔다. 
base + limit의 주소를 넘는 메모리 접근은 제한되며, 트랩(trap)을 발생시킨다. 

### 1.2. 주소의 할당(Address Binding)
프로그램은 이진 실행 파일 형태로 디스크에 저장되어 있다. 
이 프로그램이 실행되기 위해서는 주 메모리로 올라와서 "프로세스"가 되어야 한다. 

프로그램은 여러 단계를 거쳐 실행되고, 단계를 거치는 동안 주소들은 여러가지 다른 표현 방식을 거치게 된다. 
원시 프로그램에서 주소는 (변수 count와 같이)심볼 형태로 표현된다. 
컴파일러는 이 심볼 주소를 (모듈의 시작으로부터 14바이트와 같이)재배치 가능 주소로 바인딩시킨다. 
링커(linkage editor)나 로더(loader)는 재배치 가능 주소를 (74014번지 같이)절대 주소로 바인딩시킨다. 
각각의 바인딩 과정은 한 주소 공간에서 다른 주소 공간으로 맵핑하는 것이다. 

일반적으로 명령어와 데이터를 메모리 주소로 바인딩하는 시점은 다음과 같이 구분된다. 
* 컴파일 시간(complie time) 바인딩
	- 프로세스가 메모리 내에 들어갈 위치를 컴파일 시간에 알 수 있다면 컴파일러는 절대 코드를 생성할 수 있다. 
* 적재 시간(load time) 바인딩
	- 프로세스가 메모리 어느 위치에 있을 지 컴파일 시점에 알지 못하면, 컴파일러는 이진 코드를 재배치 가능 코드로 만든다. 
	- 이 경우 메모리에 적재되는 시간까지 바인딩이 미뤄진다.
* 실행 시간(execution time) 바인딩
	- 프로세스가 실행 중 메모리의 한 세그먼트에서 다른 세그먼트로 옮겨질 수 있다면 실행 시간까지 바인딩이 미뤄진다. 
	- 특별한 하드웨어가 필요하다. 

### 1.3. 논리 대 물리 주소공간(Logical-Versus Physical-Address Space)
CPU가 생성하는 주소는 논리 주소(logical address)라 불리며, 메모리가 참조하는 주소(메모리 주소 레지스터(MAR)에 있는 주소)는 물리 주소(physical address)라 한다. 
