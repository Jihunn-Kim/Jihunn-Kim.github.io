---
title: "운영체제 요약 - 1. 서론"
last_modified_at: 2021-01-22
excerpt: ""
categories:
  - operating_system
---

## 1. 운영체제가 하는 일
운영체제는 사용자가 하드웨어를 효율적이고 편리하게 사용할 수 있도록 한다. 
컴퓨터 시스템의 자원들을(CPU 시간, 메모리 공간 등) 프로그램과 사용자에게 할당하고 관리한다. 
또한, 프로그램의 실행과 입출력 장치의 작동 등을 제어하는 제어 프로그램이기도 하다. 
컴퓨터에서 항상 실행되는 프로그램으로, 커널이라고도 불린다. 

## 2. 컴퓨터 시스템의 구성

# 컴퓨터 시스템 연산
범용 컴퓨터 시스템은 공유 메모리에 대한 접근을 제공하는 공통 버스와 이에 연결된 여러 개의 장치 제어기(장치 관리)와 하나 이상의 CPU로 구성되어 있다. 
공유 메모리에는 메모리 제어기가 있어 메모리 접근 순서 등을 관리한다. 
컴퓨터에 전원이 들어오면, 펌웨어라 알려진 읽기 전용 메모리(ROM)에 있는 부트스트랩 프로그램이 하드 디스크같은 보조 기억 장치에서 운영체제를 메모리에 적재한다. 
그 후 운영체제가 사용자에게 서비스를 제공한다. 
하드웨어는 시스템 버스를 통해 CPU에게 인터럽트 신호(입출력 요구 등)를 보낼 수 있으며, 소프트웨어는 시스템 호출(system call)로 인터럽트를 발생시킬 수 있다. 
CPU가 인터럽트 되면, CPU는 실행 중인 프로그램을 멈추고 인터럽트를 처리하는 서비스 루틴을 수행한다. 
인터럽트 서비스 루틴을 마치면 원래 프로그램으로 돌아온다. 

# 저장 장치 구조
CPU는 명령어를 메모리에서만 가져올 수 있으므로, 프로그램은 반드시 메모리에 있어야 한다. 
메모리의 내용은 CPU 내부의 레지스터로 옮겨져 수행된다. 
속도, 가격, 크기, 휘발성 여부 등에 따라 다양한 저장 장치 시스템이 존재한다. (NVRAM, SSD, 플래시 메모리 등) 

# 입출력 구조
장치 제어기는 로컬 버퍼 저장 장치를 가지고 있으며, 장치로부터 들어오는 데이터를 버퍼에 저장한다. 
이후 CPU에게 인터럽트를 보내 버퍼에 있는 데이터를 CPU에게 전송한다. 
하지만, 입출력의 내용이 CPU를 거쳐 메모리로 이동하면 시간이 낭비될 수 있다. 
따라서 직접 메모리 접근(DMA)장치가 사용된다. 
이는 CPU의 도움 없이 메모리와 직접 소통하여 데이터를 주고 받을 수 있다. 

## 3. 컴퓨터 시스템 구조

# 다중 처리기 시스템
CPU가 하나만 사용되면 단일 처리기(single-processor)이고 여러 개가 사용되면 다중 처리기(multiprocessor) 또는 멀티코어라고 한다. 
처리기가 많아지면 처리량이 증가하며, 하나의 처리기가 고장나도 시스템이 정지하지 않기에 신뢰성이 향상된다. 
다중 처리기 시스템은 두 가지 형태를 지닌다. 
1. 비대칭적 다중 처리
	- 하나의 주 처리기가 시스템을 제어함(작업 스케줄링 등)
	- 다른 처리기들은 주 처리기의 명령을 수행하거나 미리 정의된 일을 수행함
2. 대칭적 다중 처리
	- 주종 관계가 없이 공유 메모리를 사용함.
	- 각 처리기에는 로컬 레지스터와 캐시 메모리가 존재.

# 클러스터형 시스템
클러스터 시스템은 둘 이상의 독자적 시스템 또는 노드들을 연결하여 구성한다. 
클러스터 컴퓨터는 저장 장치를 공유하고 근거리 통신망이나 InfiniBand와 같은 고속의 상호 연결망으로 연결된다. 

## 4. 운영체제의 구조
운영체제 내부 구조는 매우 다양하다. 그럼에도 공통점들이 많이 있기에 이를 설명한다. 
운영체제의 가장 중요한 면은 다중 프로그램을 할 수 있는 능력이다. 
여러 작업을 메모리에 적재하고, 이들 중 하나를 선택해 실행한다. 
작업이 입출력의 종료를 기다리는 등의 어떤 일을 기다려야 할 때, CPU는 쉬지 않고 다른 작업을 실행함으로써 CPU이용률을 증가시킨다. 

운영체제는 어떤 작업을 메모리에 올릴 지 결정하는 작업 스케줄링, 동시에 실행 준비된 작업 중 하나를 선택하는 CPU 스케줄링도 관리한다. 
이외에도 파일 시스템, 디스크, 자원 보호, 작업 동기화, 통신 등을 관리한다. 

## 5. 운영체제 연산

# 이중 연산 모드
운영체제의 적절한 동작을 보장하기 위해, 운영체제 코드의 실행과 사용자 정의 코드의 실행을 구분할 수 있어야 한다. 
적어도 두 개의 독립된 연산 모드, 사용자 모드와 커널 모드(수퍼바이저 모드, 시스템 모드 혹은 특권 모드)를 필요로 한다. 
이는 모드 비트라고 불리는 하나의 비트가 현재의 모드를 나타내기 위해 하드웨어에 추가되었다. 
사용자 프로그램이 불법적인 명령을 수행하려 하거나 사용자 주소 공간이 아닌 메모리에 접근을 시도하는 등과 같은 오류를 막기 위해 
일부 명령을 특권 명령으로 지정한다. 그리고 하드웨어는 특권 명령이 커널 모드에서만 수행되도록 한다. 
모드 규칙을 위반하는 오류가 탐지되면, 적절한 오류 메세지가 주어지며, 프로그래머가 조사할 수 있도록 프로그램의 메모리가 파일로 덤프된다. 

# 타이머
타이머는 운영체제가 CPU에 대한 제어를 유지할 수 있도록 보장한다. 
사용자 프로그램이 무한 루프에 빠지거나 시스템 호출에 실패하여. 제어가 운영체제로 복귀 하지 않는 경우를 방지한다. 
프로그램에 할당된 제한 시간이 초과되면 운영체제에게 제어가 돌아간다. 

## 6. 프로세스 관리
실행되고 있는 프로그램을 일반적으로 프로세스라고 한다. 
프로그램은 디스크에 저장된 파일의 내용과 같이 수동적 개체인 반면, 프로세스는 다음 수행할 명령을 지정하는 프로그램 카운터(PC)를 가진 능동적 개체이다. 
다중 스레드 프로세스는 복수 개의 프로그램 카운터를 가지고 있으며, 이 카운터들은 각 스레드가 실행할 다음 명령어를 가르킨다. 
운영체제는 프로세스 중지, 동기화, 생성, 제거, 스케줄 등을 관리한다. 

## 7. 메모리 관리
프로그램이 수행되기 위해서는 메모리에 적재되어야 한다. CPU 이용률과 컴퓨터 응답 속도 개선을 위해, 메모리에 여러 개의 프로그램이 유지되어야 한다. 
이를 위해 운영 체제는 메모리 관리 기법을 사용한다. 메모리의 어느 부분이 사용되고 있으며 누구에 의해 사용되고 있는지를 추적한다. 
또한 어떤 프로세스는 메모리에 적재하고 제거할지 결정하고, 메모리 공간을 할당하고 회수해야 한다.

## 8. 저장장치 관리

# 파일 시스템 관리
컴퓨터는 여러 타입의 물리적 매체에 정보를 저장할 수 있다. 
운영체제는 저장 장치의 물리적 특성을 추상화하여 논리적인 저장 단위인 파일을 정의한다. 
저장 장치와 그것을 제어하는 장치를 관리함으로써 파일의 추상적인 개념을 구현한다. 
저장 장치의 다양한 특성과 접근, 생성 방법 등을 사용자가 알 필요 없도록 파일을 관리한다. 

# 대용량 저장장치 관리
대부분의 컴퓨터 시스템은 디스크를 프로그램과 데이터를 위한 저장 매체로 사용하고 있다. 
운영체제는 디스크 자유 공간의 관리, 저장 장소 할당, 디스크 스케줄링을 관리한다. 
CD, DVD 드라이브 같은 3차 저장 장치도 사용된다. 
운영체제는 사용자가 컴퓨터 파일 시스템을 통해 저장 장치에 접근할 수 있도록 파일 및 디렉토리를 만드는 마운트도 담당한다. 

# 캐싱
캐시 메모리와 같이 접근 속도가 빠른 저장 장치에 자주 사용되는 정보를 보관한다면 접근에 소비되는 시간이 줄어든다.  
캐시의 크기와 교체 정책을 잘 선택하면 모든 접근의 90% 정도를 캐시에서 얻을 수 있다. 
하지만 캐시의 크기에 한계가 있기 때문에, 캐시 관리가 중요한 문제가 된다. 
특히, 여러 개의 CPU와 각각에 로컬 캐시가 있다면 주 메모리의 데이터가 동시에 여러 캐시에 존재할 수 있다. 
이때 한 캐시에서 값의 갱신이 이루어질 경우, 다른 캐시의 값을 수정하여 캐시의 일관성을 다루어야 한다. 

# 입출력 시스템
운영체제의 입출력 시스템은 버퍼와 캐싱 등 메모리 관리, 장치 드라이버, 데이터 전송 등을 관리한다. 

## 9. 보호와 보안
컴퓨터 자원에 대해 프로그램 또는 사용자들의 접근을 제어하고 바이러스, 식별자 도용 등을 막아야 한다. 
운영체제는 사용자 식별자, 그룹 식별자, 유효 사용자 식별자 등을 사용하여 그에 맞는 권한을 부여하고 관리한다. 

## 10. 커널 자료 구조
운영체제 구현에 사용되는 기본 자료 구조들이 있다. 
리스트, 스택, 큐, 트리, 해시 맵, 비트맵 등이 사용된다. 

## 11. 계산 환경


