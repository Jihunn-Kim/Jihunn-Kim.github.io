---
title: "컴퓨터 네트워킹 요약 - 4. 네트워크 계층: 데이터 평면
last_modified_at: 2021-02-24
show_date: true
classes: wide
excerpt: ""
categories:
  - computer_networking
---

## 4.1. 네트워크 계층 개요(Overview of Network Layer)

### 4.1.1. 포워딩과 라우팅: 데이터 평면과 제어 평면(Forwarding and Routing: The Data and Control Planes)
네트워크 계층은 송신 호스트에서 수신 호스트로 패킷을 전달하는 것이다. 
네트워크 계층의 중요 기능은 다음과 같다. 

1. 포워딩(Forwarding): 패킷이 라우터의 입력 링크에 도달했을 때, 그 패킷을 적절한 출력 링크로 이동시켜야 한다. 
2. 라우팅(Routing): 패킷 경로를 결정해야 한다. 경로를 계산하는 알고리즘을 라우팅 알고리즘(routing algorithm)이라 한다. 

포워딩은 짧은 시간(몇 나노초)단위를 갖기에 보통 하드웨어에서 실행된다. 
반면에, 라우팅은 데이터그램의 출발지-목적지 경로를 결정하는데 더 긴 시간(보통 초)단위를 갖기에 보통 소프트웨어에서 실행된다. 

라우터에는 포워딩 테이블(forwarding table)이 있다. 
라우터는 패킷 헤더의 필드 값을 조사하여 패킷을 포워딩한다. 
이 값을 포워딩 테이블의 내부 색인으로 사용한다. 

#### 4.1.1.1. 제어 평면: 전통적인 접근(Control Plane: The Traditional Approach)
라우팅 알고리즘은 포워딩 테이블의 내용을 결정한다. 
라우터의 라우팅 알고리즘은 다른 라우터의 라우팅 알고리즘과 소통하며 포워딩 테이블의 값들을 계산한다(5.2~5.4절 내용). 

#### 4.1.1.2. 제어 평면: SDN 접근(Control Plane: The SDN Approach)
원격제어가 포워딩 테이블을 계산과 배분하는 동안 라우팅 기기는 포워딩만을 수행하는 제어 평면적 접근 SDN(software defined networking)도 있다. 
원격 컨트롤러가 신뢰성과 중복성을 갖춘 원격 데이터 센터에 설치될 수 있으며, 라우터와 메세지를 교환함으로써 소통할 수 있다. 
네트워크가 소프트웨어적으로 정의되었을 때, 포워딩 테이블을 계산하는 컨트롤러는 라우터와 상호작용을 하여 소프트웨어에서 실행된다. 

### 4.1.2. 네트워크 서비스 모델(Network Service Model)
네트워크 계층에서 제공할 수 있는 서비스들의 일부는 다음과 같다. 이 외에 수많은 변형들이 있다. 
* 보장된 전달: 패킷이 출발지에서 목적지까지 도착하는 것을 보장한다. 
* 지연 제한 이내의 보장된 전달: 패킷의 전달 보장뿐만 아니라 호스트간의 특정 지연 제한 안에 전달한다. 
* 순서화(in-order) 패킷 전달: 패킷이 목적지에 송신된 순서로 도착하는 것을 보장한다. 
* 최소 대역폭 보장: 송신과 수신 호스트 사이에 특정한 비트 속도의 전송 링크를 에뮬레이트(emulates)한다. 송신 호스트가 비트를 특정한 비트 속도 이하로 전송하는 한, 모든 패킷이 수신 호스트까지 전달된다. 
* 보안(security): 데이터그램을 송신 호스트에서는 암호화, 수신 호스트에서는 해독을 할 수 있게 한다. 

인터넷의 네트워크 계층은 최선형 서비스(best-effort service)라고 알려진 서비스를 제공한다. 
이는 패킷 순서, 전송, 지연, 최소 대역폭을 보장하지 않는다. 
다른 여러 네트워크 구조는 최선형 서비스보다 좋은 서비스 모델을 정의하고 구현하였다. 
예를 들어, ATM 네트워크 구조는 패킷 순서, 지연, 최소 대역폭을 보장한다. 
그럼에도 최선형 서비스 모델은 많은 애플리케이션에 "충분히 좋다"라고 입증되고 있다. 

## 4.2. 라우터 내부에는 무엇이 있을까?(What's Inside a Router?)
<figure style="width: 600px" class="align-center">
 	<img src="{{ '/assets/img/bio-photo.jpg' }}" alt=""> 
 	<figcaption>그림 4.4 555</figcaption>
</figure> 

라우터의 네가지 요소를 다음과 같이 정의한다. 
여기서 포트라는 용어는 물리적인 입출력 라우터 인터페이스를 의미한다. 
애플리케이션 및 소켓과 관련된 포트와는 다르다. 

(1) **입력 포트**: 입력 포트는 입력 링크의 물리 계층 기능, 입력 링크의 반대편에 있는 링크 계층과 상호 운용하기 위해 필요한 링크 계층 기능을 수행한다. 
그리고 검색 기능을 수행하는데, 이는 포워딩 테이블을 참조하여 패킷이 스위칭 구조를 통해 전달되는 라우터 출력 포트를 결정한다. 
제어패킷(예: 라우팅 프로토콜 정보를 전달하는 패킷)은 입력 포트에서 라우팅 프로세서로 전달된다. 

(2) **스위칭 구조**: 스위칭 구조는 입력 포트와 출력 포트를 연결한다. 스위칭 구조는 라우터 내부에 포함되어 있다. 

(3) **출력 포트**: 출력 포트는 스위칭 구조에서 수신한 패킷을 저장하고, 필요한 링크 계층 및 물리적 계층 기능을 수행하여 출력 링크로 패킷을 전달한다. 
링크가 양방향일 때, 출력 포트는 일반적으로 동일한 링크의 입력 포트와 한 쌍을 이룬다. 

(4) **라우팅 프로세서**: 라우팅 프로세서는 제어 평면 기능을 수행한다. 기존의 라우터에선느 라우팅 프로토콜을 실행하고, 라우팅 테이블과 연결된 링크 상태 정보를 유지 관리하며 포워딩 테이블을 계산한다. 
SDN 라우터에서는 원격 컨트롤러와 통신하여, 원격 컨트롤러에서 계산된 포워딩 테이블 항목을 수신하고 입력 포트에 이 항목을 설치한다. 

라우터의 입력 포트, 출력 포투, 스위칭 구조는 보통 하드웨어로 구현된다. 
10Gbps 입력 링크와 64바이트 IP 데이터그램을 생각해보면, 입력 포트는 다른 데이터 그램이 오기 전에 도착한 데이터 그램을 처리하는 데 51.2 ns 밖에 시간이 없다. 
더군다나 N개의 포트가 회선 카드(line card)에 결합되어 있으면, 데이터그램-처리 파이프라인은 N배 더 빨라져야 한다. 
이는 소프트웨어로 구현하기에는 힘들 정도로 빠른 요구 속도이다. 

반면 라우터의 제어기능(라우팅 프로토콜 실행-SDN의 경우 원격 컨트롤러와 소통, 관리 기능 수행 등)은 밀리초나 초 단위로 수행된다. 
따라서, 이러한 제어 평면 기능들은 보통 소프트웨어로 구현되며 라우팅 프로세서(보통 일반적인 CPU)에서 실행된다. 

### 4.2.1. 입력 포트 처리 및 목적지 기반 전달(Input Port Processing and Destination-Based Forwarding)
포워딩 테이블은 라우팅 프로세서에서 계산되거나 원격 SDN 컨트롤러엣서 수신된다. 
포워딩 테이블은 그림 4.4의 입력 회선 카드로 복사되어, 패킷 마다 라우팅 프로세서를 호출할 필요가 없어진다. 
 
패킷이 32비트 IP 목적지 주소를 갖고, 4개의 링크가 있다고 하자. 
그러면 아래와 같이 링크 인터페이스를 결정할 수 있다. 
```console
	목적지 주소 범위		링크 인터페이스
11001000 00010111 00010000 00000000		
		~				0
11001000 00010111 00010111 11111111

11001000 00010111 00011000 00000000
		~				1
11001000 00010111 00011000 11111111

11001000 00010111 00011001 00000000
		~				2
11001000 00010111 00011111 11111111

	      그 외				3


	프리 픽스		링크 인터페이스
11001000 00010111 00010			0

11001000 00010111 00011000		1

11001000 00010111 00011			2

	  그 외				3
```

포워딩 테이블에서 라우터는 패킷의 목적지 주소의 프리픽스(prefix)를 테이블의 항목과 대응시킨다. 
만약 앞 3개의 엔트리에 대응되지 않으면 최장 프리픽스 매칭 규칭(longest prefix matching rule)을 적용한다. 
테이블에서 가장 긴 대응 항목을 찾고, 이에 대응된 링크 인터페이스로 패킷을 보낸다. (4.3절 내용)

프리픽스를 빠르게 찾기 위해, 빠른 검색 알고리즘(lookup algorithms), 내장형 DRAM과 빠른 SRAM, TCAM(Ternary Content Addressable Memories) 등이 활용된다. 
검색을 통해 패킷의 출력 포트가 결정되면 패킷을 스위칭 구조로 보낼 수 있다. 

### 4.2.2. 변환기(Switching)
스위칭 구조를 통해 패킷이 입력 포트에서 출력 포트로 전달된다. 
 
<figure style="width: 600px" class="align-center">
 	<img src="{{ '/assets/img/bio-photo.jpg' }}" alt=""> 
 	<figcaption>그림 4.6 66</figcaption>
</figure> 

(1) 메모리를 통한 교환: 패킷이 도착하면, 입력 포트는 라우팅 프로세서에게 인터럽트를 보내 패킷을 프로세서 메모리에 복사한다. 
그 다음 라우팅 프로세서는 헤더에서 주소를 추출하고 포워딩 테이블에서 출력 포트를 찾은 다음, 패킷을 출력 포트의 버퍼에 복사한다. 
목적지 포트가 다른 경우라도 공유 시스템 버스를 통해 한 번에 하나의 메모리 읽기/쓰기 작업을 할 수 있기 때문에 두 패킷을 동시에 전달할 수 없다. 

최근 라우터는 회선 카드에서 이를 처리한다. 
회선 카드에서 패킷을 처리하고 출력 포트의 메모리에 스위칭(쓰기)한다. 

(2) 버스를 통한 교환: 입력 포트가 라우팅 프로세서의 개입 없이 공유 버스를 통해 직접 출력 포트로 패킷을 전송한다. 
이는 일반적으로 입력 포트가 출력 포트를 가르키는 스위치 내부 라벨/헤더(switch-internal label(header))을 패킷에 붙이고, 패킷을 버스에 보냄으로써 수행된다. 
모든 출력 포트이 패킷을 수신하지만, 라벨과 일치하는 포트만 패킷의 라벨을 제거하고 유지한다. 

한번에 하나의 패킷만 버스를 통과할 수 있기 때문에, 다른 패킷들은 대기해야 한다. 

(3) 인터커넥션 네트워크(interconnection network)를 통한 교환: 크로스바(crossbar) 스위치는 그림 4.6처럼 구성되어 있다. 
각 수직 버스는 교차점에서 각 수평 버스와 교차하며, 스위치 구조 컨트롤러에 의해 언제든지 열거나 닫을 수 있다. 

크로스바 스위치에서 다른 출력 포트로 보내지는 패킷들은 병렬적으로 전달될 수 있다. 

이 외에도 다단계 스위칭 구조, 3단계 논 블록킹(non-blocking) 등 여러 방식이 있다. 

### 4.2.3. 출력 포트 프로세싱(Output Port Processing)
출력 포트 프로세싱은 출력 포트의 메모리에 저장된 패킷을 가져와 출력 링크를 통해 전송한다. 
패킷 선택 및 대기열 제거(de-queueing packets), 필요한 링크 계층 및 물리 계층 전송 기능을 수행한다. 

### 4.2.4. 어디에서 큐잉이 일어날까?(Where Does Queuing Occur?)
패킷 큐는 입력 포트와 출력 포트 모두에서 형성될 수 있다. 

#### 4.2.4.1. 입력 큐잉(Input Queueing)
스위칭 구조 전송속도가 입력 회선 속도에 비해 느리면, 패킷이 스위칭 구조를 통해 출력 포트로 전송되기 위해서 차례를 기다려야 한다. 
각 입력 포트의 앞쪽 패킷들이 같은 출력 포트로 가려고 하면 대기하는 것은 당연하다. 
하지만 경쟁없는 다른 출력 포트로 가려하는 뒤쪽 패킷들도 앞쪽 패킷이 사라질 때까지 기다려야 한다. 
이 현상을 HOL(head-of-the-line) 차단이라고 한다. 

#### 4.2.4.2. 출력 큐잉(Output Queueing)
N개의 입력 포트에서 스위칭 구조 전송속도가 입력 회선 속도보다 N배 빠른 경우에도 출력 포트에서 패킷 큐잉이 발생할 수 있다. 
대기 중인 패킷의 수가 출력 포트에서 사용 가능한 메모리보다 많아질 수 있다. 
예를 들어, 계속 N개의 패킷이 동시에 들어와 하나의 출력 패킷으로 들어갈 수도 있다. 

메모리가 충분하지 않을 때, 들어오는 패킷을 폐기(drop-tail 정책)하거나 큐에 있는 패킷을 삭제할 수 있다. 
혹은 큐가 가득차기 전에, 패킷을 폐기하거나 헤더에 기록(mark)하여 송신자에게 혼잡 상태를 알릴 수도 있다. 

### 4.2.5. 패킷 스케줄링(Packet Scheduling)
큐에 있는 패킷을 출력 링크를 통해 전송하는 순서를 결정하는 방법이 있다. 

#### 4.2.5.1. First-in-First-Out(FIFO)
First-come-First-served(FCFS) 라고도 알려진 FIFO는 출력 링크 큐에 도착한 순서와 동일한 순서로 출력 링크에서 전송할 패킷을 선택한다. 

#### 4.2.5.2. 우선순위 큐잉(Priority Queuing)
패킷은 우선순위 클래스로 분류된다. 
예를 들어, 네트워크 관리 정보, 실시간이 필요한 패킷은 높은 우선순위를 받을 수 있다. 
각 우선순위 클래스에 큐가 있으며, 동일한 우선순위 패킷들은 일반적으로 FIFO방식이 행해진다. 

#### 4.2.5.3. 라운드 로빈과 WFQ(Round Robin and Weighted Fair Queuing (WFQ))
패킷은 우선순위 큐잉과 같이 클래스로 분류된다. 
그러나 클래스간 우선순위가 없고, 스케줄러가 클래스 간에 서비스를 번갈아서(예: 1, 2, 1, ...) 제공한다. 

작업 보존(work-conserving) 큐잉 규칙은 라운드 로빈과 아래 나올 WFQ에도 사용된다. 
차례가 된 클래스에 패킷이 없다면, 다음 클래스로 바로 넘어간다. 

WFQ는 라운드 로빈과 유사하지만, 각 클래스에 가중치를 준다. 
각 클래스마다 다른 양의 서비스 시간을 부여할 수 있다. 

## 4.3. 인터넷 프로토콜(IP): IPv4, 주소지정, IPv6 등(The Internet Protocol(IP): IPv4, Addressing, IPv6, and More)

### 4.3.1. IPv4 데이터그램 형식(IPv4 Datagram Format)
IP 데이터그램은 총 20바이트의 헤더(옵션 없을 시)를 갖는다. 
데이터그램이 TCP 세그먼트를 전송한다면, 총 40바이트의 헤더(IP 헤더 20, TCP 헤더 20)를 전송한다. 

(1) 버전 번호: IP 프로토콜 버전을 명시한다. 

(2) 헤더 길이: 헤더에 가변 길이의 옵션을 포함하므로, IP 데이터그램에서 실제 페이로드(payload, 예: 데이터그램에 캡슐화된 세그먼트)가 시작하는 곳을 결정한다. 

(3) 서비스 타입: Type of service(TOS) 비트는 서로 다른 유형의 IP 데이터그램을 구별한다. 
예를 들어 실시간 데이터그램(전화, 통신 등)과 비실시간 트래픽(FTP)을 구분하는 데 유용하다. 

(4) 데이터그램 길이: 바이트로 계산한 IP 데이터그램(헤더와 데이터)의 전체 길이이다. 
 
(5) 식별자, 플래그, 단편화 오프셋(4.3.2절 내용): IP 단편화에 사용된다. IPv6는 단편화를 허용하지 않는다. 

(6) TTL(Time-to-live): 네트워크에서 데이터그램이 무한히 순환하지 않도록 한다. 
이 필드 값은 라우터가 데이터그램을 처리할 때마다 감소하며, 0이 되면 데이터그램이 폐기된다. 

(7) 프로토콜: 데이터그램이 최종 목적지에 도착했을 때만 사용된다. 
이 필드 값은 데이터 부분이 전달될 목적지의 전송 계층 프로토콜을 명시한다. 
예를 들어, 6은 데이터를 TCP로, 17은 UDP로 전달하라는 의미이다. 

(8) 헤더 체크섬: IP 헤더만을 체크섬하여 오류를 검사한다. 
보통 오류가 검출된 데이터그램은 라우터에서 폐기된다. 

(9) 출발지와 목적지 IP주소: 출발지가 데이터그램을 생성할 때, 출발지와 목적지 IP 주소를 넣는다. 

(10) 옵션: 오버헤드, 처리 시간 등의 이유로 거의 사용되지 않는다. 
따라서 IPv6에 포함되지 않았다. 

(11) 데이터(페이로드, payload): 대부분 전송 계층 세그먼트이나 ICMP 메세지(5.6절)와 같은 다른 유형의 데이터도 담긴다. 

### 4.3.2. IPv4 데이터그램 단편화(Pv4 Datagram Fragmentation)
(6장 내용) 서로 다른 링크 계층 프로토콜들은 전달할 수 있는 최대 데이터그램 크기가 다를 수 있다. 
예를 들어, 이더넷 프레임은 최대 1,500바이트, 광역 링크 프레임은 576바이트가 최대 크기이다. 
링크 계층 프레임이 전달할 수 있는 최대 데이터 양을 MTU(maximum transmission unit)라 부른다. 

데이터그램은 한 라우터에서 다른 라우터로 전송되기 위해 링크 계층 프레임 내에 캡슐화된다. 
그런데, 송신자와 목적지 간의 경로의 각 링크가 다른 링크 계층 프로토콜을 사용하여(서로 다른 MTU를 가져), 데이터그램 크기에 따라 문제가 생길 수 있다. 

해결책은 IP 데이터그램의 페이로드를 더 작은 IP 데이터그램으로 분할하여 전송하는 것이다. 
이러한 작은 데이터그램을 조각(fragment, 단편)이라고 한다. 

목적지 호스트는 같은 출발지로부터 일련의 데이터그램을 수신하면, 이를 결합한다. 
IP 데이터그램의 식별자, 플래그, 단편화 오프셋이 이에 사용된다. 
송신자는 일반적으로 보내는 데이터그램마다 식별자 번호를 증가시킨다. 
수신자는 식별자 번호를 통해 어느 원본의 데이터그램 조각인지 판단한다. 
그리고 데이터그램의 마지막 조각은 플래그 비트가 0, 나머지 조각은 1인것으로 알 수 있다. 
오프셋은 조각이 분실되었는지와 재결합 순서를 위해 사용된다. 

### 4.3.3. IPv4 주소체계(IPv4 Addressing)
먼저, 호스트와 라우터가 인터넷에 연결되는 방식에 관한 단어를 정의한다. 
호스트는 일반적으로 네트워크와 연결되는 하나의 링크를 가지고, 이를 통해 데이터그램을 보낸다. 
호스트와 물리적 링크 사이의 경계를 인터페이스(interface)라고 부른다. 

라우터는 한 링크로부터 데이터그램을 수신하여 다른 링크로 전달하므로, 2개 이상의 연결된 링크를 가진다. 
라우터와 링크 사이의 경계 또한 인터페이스라 하는데, 각 링크마다 하나의 인터페이스를 가지므로 라우터는 여러 개의 인터페이스를 가진다. 

모든 호스트와 라우터는 데이터그램을 송수신할 수 있으므로, IP는 각 인터페이스가 IP 주소를 갖도록 요구한다. 
따라서 기술 면에서 IP 주소는 인터페이슬르 포함하는 호스트, 라우터보다는 인터페이스와 관련이 있다. 

각 IP주소는 32비트 길이(4바이트)이다. 
일반적으로 각 바이트를 십진수로 표현하고 바이트를 점(.)으로 구분하는 십진 표기법(dotted-decimal notation)을 사용한다. 
예를 들어, 193.32.216.9이 있으며 이진수로는 아래와 같다.  
> 11000001 00100000 11011000 00001001

모든 인터페이스는 고유한 IP 주소를 갖는다(4.3.4절 NAT 뒤의 인터페이스 예외). 
주소는 마음대로 선택할 수 없고, 주소의 일부는 연결된 서브넷(subnet)이 결정한다. 

그림 4.18에서 왼쪽 3개의 호스트와 연결된 라우터 인터페시으는 모두 223.1.1.xxx 형식의 IP 주소를 갖는다. 
즉, 동일한 왼쪽 24비트를 사용한다. 
또한 4개의 인터페이스가 중계하는 라우터 없이 (이더넷 LAN 혹은 무선 엑세스포인트로, 6, 7장 내용) 하나의 네트워크에 서로 연결되어 있다. 
IP 용어로 이 네트워크는 서브넷을 구성한다고 말한다. 
IP 주소체계는 이 서브넷에 223.1.1.0/24 라는 주소를 할당하는데, 여기서 /24 는 서브넷 마스크(subnet mask)라 부른다. 
이는 32비트 주소의 왼쪽 24비트가 서브넷 주소라는 것을 가리킨다. 
네트워크 223.1.1.0/24에 새로 부착할 호스트에는 223.1.1.xxx 형식의 주소가 필요할 것이다. 

<figure style="width: 600px" class="align-center">
 	<img src="{{ '/assets/img/bio-photo.jpg' }}" alt=""> 
 	<figcaption>그림 4.18 77</figcaption>
</figure> 

서브넷의 IP 정의는 여러 호스트가 라우터 인터페이스에 연결된 것만을 의미하지는 않는다. 
일반적인 라우터와 호스트를 연결한 시스템에서 서브넷을 정의하기 위해 다음과 같은 방법을 사용할 수 있다. 
<div class="notice--primary" markdown="1">
서브넷을 결정하려면, 호스트나 라우터에서 인터페이스를 분리하고, 고립된 네트워크를 만든다. 
이 고립된 네트워크의 종단점은 인터페이스의 끝이 된다. 
이렇게 고립된 네트워크 각각을 서브넷이라고 한다. 
</div>
그림 4.20처럼 호스트들-라우터 3개 외에 라우터-라우터 3개, 총 6개의 고립된 서브넷을 가질 수 있다. 

<figure style="width: 600px" class="align-center">
 	<img src="{{ '/assets/img/bio-photo.jpg' }}" alt=""> 
 	<figcaption>그림 4.20 88</figcaption>
</figure>  